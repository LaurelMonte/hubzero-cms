<?php

  // include base peer class
require_once 'lib/data/om/BaseDataFilePeer.php';

// include object class
include_once 'lib/data/DataFile.php';


/**
 * Skeleton subclass for performing query and update operations on the 'DataFile' table.
 *
 *
 *
 * This class was autogenerated by Propel on:
 *
 * Sat Feb  9 00:02:51 2008
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.data
 */
class DataFilePeer extends BaseDataFilePeer {

  /**
   * Find a DataFile object based on its ID
   *
   * @param int $id
   * @return DataFile
   */
  public static function find($id) {
    return self::retrieveByPK($id);
  }


  /**
   * Find all DataFile objects includes all datafiles that mark with deleted
   *
   * @return array <DataFile>
   */
  public static function findAll() {
    return self::doSelect(new Criteria());
  }

  /**
   * Get the column name that return from the Search
   *
   * @return array of String of column names
   */
  public static function getKeywordSearchColumns() {
    return array(
        self::NAME,
        self::TITLE,
        self::AUTHORS,
        self::DESCRIPTION
    );
  }


  /**
   * Find DataFile object by full path
   * SELECT * FROM DataFile WHERE concat(path,'/',name)= ? AND NOT deleted
   *
   * @param String $path_and_name
   * @return DataFile object
   */
  public static function findByFullPath($path_and_name) {

    $path = dirname($path_and_name);
    $name = basename($path_and_name);

    return self::findOneMatch($name, $path);

  }


  /**
   * Find DataFile id by name and path recursively
   * SELECT id FROM DataFile WHERE name=? AND path like ? AND NOT deleted
   *
   * @param String $name
   * @param String $path_like
   * @return array of DataFile ids
   */
  public static function findByNamePath($name, $path_like) {
    $c = new Criteria();
    $c->clearSelectColumns();
    $c->addSelectColumn(self::ID);
    $c->add(self::NAME, $name);
    $c->add(self::PATH, $path_like, Criteria::LIKE);
    $c->add(self::DELETED, 0);
    return self::doSelectRS($c);
  }


  /**
   * Find all DataFile objects (files and directories) in current path only, not in sub-directories
   * SELECT * FROM DataFile WHERE path = ? AND NOT deleted
   *
   * @param String $path: current path
   * @return array of DataFile objects
   */
  public static function findByDirectory($path) {
    $c = new Criteria();
    $c->add(self::PATH, $path);
    $c->add(self::DELETED, 0);
    $c->addDescendingOrderByColumn(self::DIRECTORY);
    return self::doSelect($c);
  }



  /**
   * Find all DataFile object within a path, return order of directories first and then files
   * SELECT * FROM DataFile WHERE path = ? AND NOT deleted order by directory desc
   *
   * @param String $path
   * @return array of DataFile objects
   */
  public static function findByDirectoryWithOrderBy($path) {
    $c = new Criteria();
    $c->add(self::PATH, $path);
    $c->add(self::DELETED, 0);
    $c->addDescendingOrderByColumn(self::DIRECTORY);

    return self::doSelect($c);
  }



  /**
   * Find only DataFile objects that are FILES only in the given path
   * SELECT * FROM DataFile WHERE path = ? and NOT directory AND NOT deleted
   *
   * @param String $path
   * @return array <DataFile>
   */
  public static function findFilesByDirectory($path) {
    $c = new Criteria();
    $c->add(self::PATH, $path);
    $c->add(self::DELETED, 0);
    $c->add(self::DIRECTORY, 0);

    return self::doSelect($c);
  }



  /**
   * Find all DataFile Objects by a given path-like (using in: DeleteChannelList)
   * SELECT * FROM DataFile WHERE path like ? AND NOT deleted
   *
   * @param String $path: the path of data file
   * @return array <DataFile>
   */
  public static function findByConfigId($path) {

    $c = new Criteria();
    $c->add(self::PATH, "%$path", Criteria::LIKE);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }



  /**
   * Find all DataFiles (directories and files) in a given path
   * SELECT * FROM DataFile WHERE path LIKE ? AND NOT deleted
   *
   * @param String $path
   * @return array <DataFile>
   */
  public static function findAllInDir($path) {
    $c = new Criteria();
    $c->add(self::PATH, "CONCAT(" . self::PATH . ", '/') LIKE '" . self::double_single_quote($path) . "/%'", Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addDescendingOrderByColumn(self::DIRECTORY);
    $c->addAscendingOrderByColumn(self::PATH);
    return self::doSelect($c);
  }


  /**
   * Find all DataFiles that are files only not directories by a given path
   * SELECT * FROM DataFile WHERE concat(path,'/') LIKE ? AND NOT directory AND NOT deleted
   *
   * @param String $pathlike: the path-like directory
   * @return array of DataFile objects
   */
  public static function findFilesInDirs($path) {
    $c = new Criteria();
    $c->add(self::PATH, "CONCAT(" . self::PATH . ", '/') LIKE '" . self::double_single_quote($path) ."/%'", Criteria::CUSTOM);
    $c->add(self::DIRECTORY, 0);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find the DataFile object given the path and name, must be return only one DataFile
   * SELECT * FROM DataFile WHERE name=? AND path=? AND NOT deleted
   *
   * @param String $name
   * @param String $path
   * @return DataFile
   */
  public static function findOneMatch($name, $path) {
    $c = new Criteria();
    $c->add(self::NAME, $name);
    $c->add(self::PATH, $path);
    $c->add(self::DELETED, 0);

    return self::doSelectOne($c);
  }


  /**
   * Find all DataFiles (directories and files) in a given path
   * SELECT * FROM DataFile WHERE path LIKE ? AND NOT deleted
   *
   * @param String $pathlike: the path-like directory
   * @return array of DataFile objects
   */
  public static function findAllExport($pathlike) {
    return self::findAllInDir($pathlike);
  }


  /**
   * Find all dataFiles (directoris and files) given by a path
   * SELECT * FROM DataFile WHERE concat(path,'/') LIKE ? AND NOT deleted ORDER BY directory desc, path, name
   *
   * @param String $pathlike
   * @return array of dataFile Objects in order of 1/Directory 2/Path 3/Name
   */
  public static function findAllWithOrder($pathlike) {
    $c = new Criteria();
    $c->add(self::PATH, "CONCAT(" . self::PATH . ", '/') LIKE '" . self::double_single_quote($pathlike) ."'", Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addDescendingOrderByColumn(self::DIRECTORY);
    $c->addAscendingOrderByColumn(self::PATH);
    $c->addAscendingOrderByColumn(self::NAME);

    return self::doSelect($c);
  }




  /**
   * Find the thumbnail associate with an entity given by the EntityID and EntityTypeId
   * SELECT d.* FROM DataFile d, Thumbnail t WHERE d.id = t.datafileId AND t.entityId = ? AND t.entity_type_id = ?
   *
   * @param int $entityId: The Id of entity
   * @param int $entityTypeId: The ID of entity Type (Project = 1, Experiment = 3...)
   * @return DataFile Object that represents for the thumbnail
   */
  public static function findThumbnailDataFile($entityId, $entityTypeId) {

    require_once 'lib/data/ThumbnailPeer.php';

    $c = new Criteria();
    $c->addJoin(self::ID, ThumbnailPeer::DATAFILE_ID);
    $c->add(ThumbnailPeer::ENTITY_ID, $entityId);
    $c->add(ThumbnailPeer::ENTITY_TYPE_ID, $entityTypeId);

    return self::doSelectOne($c);
  }



  /**
   * To delete all DataFiles in the given path recursively
   * DELETE FROM DataFile WHERE concat(path,'/') LIKE ? OR concat(path,'/',name) = ?
   *
   * @param String $path: The given path
   */
  public static function deleteAllIncludedDir($path) {

    $c = new Criteria();
    $cton1 = $c->getNewCriterion(self::PATH, "CONCAT(" . self::PATH . ", '/') LIKE '" . self::double_single_quote($path) . "/%'", Criteria::CUSTOM);
    $cton2 = $c->getNewCriterion(self::PATH, "CONCAT(" . self::PATH . ", CONCAT('/'," . self::NAME . ")) = '" . self::double_single_quote($path) . "'", Criteria::CUSTOM);
    $cton1->addOr($cton2);
    $c->add($cton1);

    return self::doDelete($c);
  }



  /**
   * Delete a single DataFile given by a full path
   *
   * @param String $fullPath
   */
  public static function deleteSingleFileWithAbsolutePath($fullPath) {

    $name = basename($fullPath);
    $path = dirname($fullPath);

    $c = new Criteria();
    $c->add(self::NAME, $name);
    $c->add(self::PATH, $path);

    self::doDelete($c);
  }



  /**
   * To delete all DataFiles in the given path recursively
   * DELETE FROM DataFile WHERE path REGEXP ?
   *
   * @param String $path: The given path
   */
  public static function recursiveDelete($path) {

    return self::deleteAllIncludedDir($path);
  }



  /**
   * Get the list of DataFile (Not all fields, just Name, Directory, Created, FleSize for performance) in a given path
   * SELECT name, directory, created, filesize FROM DataFile WHERE path = ? AND NOT deleted order by $orderby $asc_or_desc
   *
   * @param String $path
   * @param String $orderby
   * @param boolean $ascending_order
   * @return the ResultSet of list of data
   */
  public static function findDataFileBrowserRS($path, $orderby = self::NAME, $ascending_order = true) {

    $c = new Criteria();
    /*
    $c->clearSelectColumns();
    $c->addSelectColumn(self::ID);
    $c->addSelectColumn(self::NAME);
    $c->addSelectColumn(self::DIRECTORY);
    $c->addSelectColumn(self::CREATED);
    $c->addSelectColumn(self::FILESIZE);
    $c->addSelectColumn(self::DESCRIPTION);
    $c->addSelectColumn(self::TITLE);
    $c->addSelectColumn(self::AUTHORS);
    $c->addSelectColumn(self::AUTHOR_EMAILS);
    $c->addSelectColumn(self::HOW_TO_CITE);
    $c->addSelectColumn(self::THUMB_ID);
    */
    $c->add(self::PATH, $path);
    $c->add(self::DELETED, 0);

    $c->addDescendingOrderByColumn(self::DIRECTORY);

    if($orderby == self::CREATED) {
      $ascending_order ? $c->addAscendingOrderByColumn(self::CREATED) : $c->addDescendingOrderByColumn(self::CREATED);
    }
    elseif($orderby == self::FILESIZE) {
      $ascending_order ? $c->addAscendingOrderByColumn(self::FILESIZE) : $c->addDescendingOrderByColumn(self::FILESIZE);
    }
    else {
      $ascending_order ? $c->addAscendingOrderByColumn(self::NAME) : $c->addDescendingOrderByColumn(self::NAME);
    }

    return self::doSelectRS($c);
  }



  /**
   * Get the list of DataFile (Not all fields, just Name, Directory, Created, FleSize for performance) in a given path
   * SELECT name, directory, created, filesize FROM DataFile WHERE path = ? AND NOT deleted order by $orderby $asc_or_desc
   *
   * @param String $path
   * @param String $orderby
   * @param boolean $ascending_order
   * @return the ResultSet of list of data
   */
  public static function findDataFileBrowser($path, $orderby = self::NAME, $ascending_order = true) {

    $c = new Criteria();
    $c->add(self::PATH, $path);
    $c->add(self::DELETED, 0);

    $c->addDescendingOrderByColumn(self::DIRECTORY);

    if($orderby == self::CREATED) {
      $ascending_order ? $c->addAscendingOrderByColumn(self::CREATED) : $c->addDescendingOrderByColumn(self::CREATED);
    }
    elseif($orderby == self::FILESIZE) {
      $ascending_order ? $c->addAscendingOrderByColumn(self::FILESIZE) : $c->addDescendingOrderByColumn(self::FILESIZE);
    }
    else {
      $ascending_order ? $c->addAscendingOrderByColumn(self::NAME) : $c->addDescendingOrderByColumn(self::NAME);
    }

    return self::doSelect($c);
  }



  /**
   * Select all directories and sub-directories given by a path, get column id, path, name only for fast performance
   * SELECT id, path, name FROM DataFile WHERE concat(path,'/') LIKE '%" . $rootpath . "%' AND not deleted AND directory ORDER BY path, name
   *
   * @param String $path
   * @return ResultSet of records
   */
  public static function findAllDirectoriesByPath($path) {
    $c = new Criteria();
    $c->clearSelectColumns();
    $c->addSelectColumn(self::ID);
    $c->addSelectColumn(self::PATH);
    $c->addSelectColumn(self::NAME);
    $c->add(self::PATH, "CONCAT(" . self::PATH . ", '/') LIKE '" . self::double_single_quote($path) . "/%'", Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->add(self::DIRECTORY, 1);
    $c->addAscendingOrderByColumn(self::PATH);
    $c->addAscendingOrderByColumn(self::NAME);

    return self::doSelectRS($c);
  }



  /**
   * Select all directories and sub-directories given by a path, get column id, path, name only for fast performance but not in Experiment
   * SELECT id, path, name FROM DataFile WHERE concat(path,'/') LIKE '%" . $rootpath . "%' AND not deleted AND directory ORDER BY path, name
   *
   * @param String $path
   * @return ResultSet of records
   */
  public static function findAllDirectoriesInProjectLevel($projectPath) {

    $c = new Criteria();
    $c->clearSelectColumns();
    $c->addSelectColumn(self::ID);
    $c->addSelectColumn(self::PATH);
    $c->addSelectColumn(self::NAME);
    $c->add(
      self::PATH, "CONCAT(" . self::PATH . ", '/') LIKE '" . $projectPath . "/%' AND " .
      self::NAME . " NOT LIKE 'Experiment-%' AND " .
      self::NAME . " NOT LIKE 'Simulation-%' AND " .
      self::PATH . " NOT LIKE '" . $projectPath . "/Experiment-%' AND " .
      self::PATH . " NOT LIKE '" . $projectPath . "/Experiment-%' AND " .
      self::PATH . " NOT LIKE '" . $projectPath . "/Simulation-%'", Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->add(self::DIRECTORY, 1);
    $c->addAscendingOrderByColumn(self::PATH);
    $c->addAscendingOrderByColumn(self::NAME);

    return self::doSelectRS($c);
  }


  /**
   * Update metada information recursively
   *
   * @param String $path
   * @param String $authors
   * @param String $authoremails
   * @param String $description
   * @param String $howtocite
   * @param String $title
   */
  public static function recursiveUpdateMetadata($path, $authors, $authoremails, $description, $howtocite, $title) {

    // Prevent mistake from our developers !
    if(empty($path)) return;

    if(empty($authors)) $authors = null;
    if(empty($authoremails)) $authoremails = null;
    if(empty($description)) $description = null;
    if(empty($howtocite)) $howtocite = null;
    if(empty($title)) $title = null;

    // select from...
    $c1 = new Criteria();
    $cton1 = $c1->getNewCriterion(self::PATH, "CONCAT(" . self::PATH . ", '/') LIKE '" . self::double_single_quote($path) . "/%'", Criteria::CUSTOM);
    $cton2 = $c1->getNewCriterion(self::PATH, "CONCAT(" . self::PATH . ", CONCAT('/'," . self::NAME . ")) = '" . self::double_single_quote($path) . "'", Criteria::CUSTOM);
    $cton1->addOr($cton2);
    $c1->add($cton1);

    // update set
    $c2 = new Criteria();
    $c2->add(self::AUTHORS, $authors);
    $c2->add(self::AUTHOR_EMAILS, $authoremails);
    $c2->add(self::DESCRIPTION, $description);
    $c2->add(self::HOW_TO_CITE, $howtocite);
    $c2->add(self::TITLE, $title);

    BasePeer::doUpdate($c1, $c2, Propel::getConnection(self::DATABASE_NAME));

  }


  /**
   * Before inserting a data file, first we need to check if this record
   * does exist or not. If yes, do an update only, else do a new insert
   *
   * @param String $name: name of data file
   * @param String $path: path of data file
   * @param timstamp $create: current timestamp that file inserts into NEEScentral
   * @param String $checksum: an error-checking technique in which the number of bits in a unit of data is summed, transmitted along with the data
   * @param boolean $directory, either 1 or 0
   * @param int $filesize, the file size in byte
   * @return DataFile object
   */
  public static function insertOrUpdateIfDuplicate($name, $path, $create, $checksum, $directory, $filesize) {

    if(strpos($path, "/nees/home") !== 0) return null;

    $df = self::findOneMatch($name, $path);

    if(! $df) {
      $df = new DataFile($name, $path, date('Y-m-d H:i:s'), $directory, 0 );
      $df->setName($name);
      $df->setPath($path);
      $df->setCurationStatus('Uncurated');
      $df->setView('MEMBERS');
      $df->setCreated($create);
    }

    if($directory) {
      $df->setChecksum(null);
      $df->setDirectory(1);
      $df->setFilesize(null);
    }
    else {
      $df->setCreated($create); // Update time if this is a file only
      $df->setChecksum($checksum);
      $df->setDirectory(0);
      $df->setFilesize($filesize);
    }

    $df->setDeleted(0);

    $df->save();
    return $df;
  }


  /**
   * Rename a data file in database
   * @usage: rename("/source_dir/.../source_name", "/dest_dir/.../dest_name")
   * @param String $source: full path of source
   * @param String $destination: full path of directory
   * @param boolean $recursive: recursively rename sub-directory, true by default
   * @return true if succeed, void if fails
   */
  public static function renameDB($source, $destination, $recursive = true) {

    // Rename the current data file.

    $newname = basename($destination);
    $newpath = dirname($destination);

    $oldname = basename($source);
    $oldpath = dirname($source);

    $conn = Propel::getConnection(self::DATABASE_NAME);

    //UPDATE DataFile SET path = ?, name = ? WHERE path = ? AND name = ?

    // set
    $c2 = new Criteria();
    $c2->add(self::PATH, $newpath);
    $c2->add(self::NAME, $newname);

    // where ...
    $c1 = new Criteria();
    $c1->add(self::PATH, $oldpath);
    $c1->add(self::NAME, $oldname);

    BasePeer::doUpdate($c1, $c2, $conn);

    if($recursive) {
      $sql = "UPDATE ".self::TABLE_NAME." SET ".self::PATH." = REPLACE(".self::PATH.", ?, ?) WHERE ".self::PATH." = ? OR ".self::PATH." LIKE ?";

      $stmt = $conn->prepareStatement($sql);
      $stmt->setString(1, $source);
      $stmt->setString(2, $destination);
      $stmt->setString(3, $source);
      $stmt->setString(4, $source . '/%');
      $stmt->executeUpdate();
    }

    return true;
  }


  /**
   * This function is to copy file or directory from one path to another path
   * If the destination does exists, then it will update its new values
   * @usage: copyDataFileDB('/dir1/dir2/file.txt', '/dir3/dir4/file.txt' )
   *
   * @param String $source: full path of source
   * @param String $destination: full path of directory
   * @param boolean $copySystemFile check if we need to copy file system (full copy)
   *
   * @return DataFile $desc_df: the new copied DataFile, false if failed (duplicate or something else)
   */
  public static function copyDataFileDB($source, $destination, $copySystemFile = false) {
    $desc_df = self::findByFullPath($destination);

    // If destination file exists, do not overwrite it, quit now
    if($desc_df) return false;

    // If the source file does not exist, how can we make a new copy ?
    $src_df = self::findByFullPath($source);
    if(is_null($src_df)) return false;

    $new_path = dirname($destination);
    $new_name = basename($destination);

    if($copySystemFile && file_exists($source)) {
      if( ! copy($source, $destination)) return false;
    }

    $desc_df = $src_df->copy();
    $desc_df->setPath($new_path);
    $desc_df->setName($new_name);
    $desc_df->save();

    return $desc_df;
  }


  /**
   * @desc
   *   replace a single quote to escape quotes, to make javascript happy
   *
   * @param $string: string to replaced
   *
   * @return
   *   String after replace.
   */
  public static function double_single_quote($string) {
    return preg_replace('/\'/', '\'\'', $string);
  }


  /**
   * Find all required N3DV files in the N3DV folder from a given list
   *
   * @param Experiment $exp
   * @return array <DataFile>
   */
  public static function findRequiredN3DVFiles(Experiment $exp) {
    $basepath = $exp->getPathname() . "/N3DV";
    $n3dvFiles = array('container1.iv', 'default_behaviors.bhv', 'moment.iv', 'disp.iv');

    $c = new Criteria();
    $c->add(self::PATH, $basepath);
    $c->add(self::NAME, $n3dvFiles, Criteria::IN);

    return self::doSelect($c);

  }
} // DataFilePeer
?>
