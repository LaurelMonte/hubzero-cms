<?php

// include base peer class
require_once 'lib/data/om/BaseProjectPeer.php';

// include object class
include_once 'lib/data/Project.php';
include_once 'lib/data/Experiment.php';
include_once 'lib/data/curation/NCCuratedObjects.php';

/**
 * Skeleton subclass for performing query and update operations on the 'Project' table.
 *
 *
 *
 * This class was autogenerated by Propel on:
 *
 * Sat Feb  9 00:03:06 2008
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.data
 */
class ProjectPeer extends BaseProjectPeer {

  static $myprojects = null;
  static $viewableprojects = null;
  static $pubprojects = null;
  static $curatedprojects = null;

  const VIEWABLE_PROJECTS_SUBQUERY =
      "SELECT DISTINCT PROJID FROM PROJECT WHERE DELETED = 0 AND VIEWABLE = 'PUBLIC'
      UNION
      SELECT E1.PROJID FROM PROJECT P1, EXPERIMENT E1 WHERE P1.DELETED = 0 AND P1.PROJID = E1.PROJID AND E1.VIEWABLE = 'PUBLIC'";

  const MY_PROJECTS_SUBQUERY =
      "SELECT DISTINCT P.PROJID
      FROM
          PROJECT P,
          AUTHORIZATION A
      WHERE
          P.DELETED = 0 AND
          A.ENTITY_TYPE_ID = 1 AND
          A.ENTITY_ID = P.PROJID AND
          A.PERSON_ID = ? ";

  const PUB_PROJECTS_SUBQUERY =
      "SELECT DISTINCT PROJID
      FROM
          PROJECT
      WHERE
          DELETED = 0 AND
          PROJID IN (SELECT PROJID FROM EXPERIMENT WHERE VIEWABLE = 'PUBLIC' AND DELETED = 0)";

  public static function getKeywordSearchColumns() {
    return array(self::NAME, self::TITLE, self::DESCRIPTION, self::CONTACT_NAME, self::SYSADMIN_NAME, self::NICKNAME);
  }


  /**
   *
   *
   */
  public static function search($searchTerms) {
    if (!$searchTerms || $searchTerms == "") {
      return null;
    }
    $searchTerms = "%$searchTerms%";
    $searchColumns = self::getKeywordSearchColumns();


    $c = new Criteria();

    $cond = array();
    foreach($searchColumns as $column){
      $cond[] = "$column LIKE '$searchTerms'";
    }
    $condStr = implode($cond, " OR ");

    $c->add(self::NAME, $condStr, Criteria::CUSTOM);
    return self::doSelect($c);
  }


  /**
   * Find Project by ProjectID or Project Name
   *
   * @param String/int $idOrName
   * @return Project
   */
  public static function find($idOrName) {
    return self::findByNameOrId($idOrName, $idOrName);
  }


  /**
   * Find all none-deleted Project
   *
   * @return array <Project>
   */
  public static function findAll() {
    $c = new Criteria();
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn(self::TITLE);

    return self::doSelect($c);
  }


  /**
   * Find One Matched Projected given by either Project Name or Project ID
   *
   * @param String $name
   * @param int $projid
   * @return Project
   */
  public static function findByNameOrId($name, $projid) {

    $c = new Criteria();

    $cton1 = $c->getNewCriterion(self::NAME, $name);
    $cton2 = $c->getNewCriterion(self::PROJID, $projid);
    $cton1->addOr($cton2);
    $c->add($cton1);
    $c->add(self::DELETED, 0);

    return self::doSelectOne($c);
  }



  /**
   * Find One Matched Projected given by a Project Name
   *
   * @param String $name
   * @return Project
   */
  public static function findByName($name) {

    $c = new Criteria();

    $c->add(self::NAME, $name);
    $c->add(self::DELETED, 0);

    return self::doSelectOne($c);
  }



  /**
   * Find a list of Project that a Person has a permission
   *
   * @param int $personId
   * @return array <Project>
   */
  public static function findByPerson($personId) {

    require_once 'lib/data/PersonEntityRolePeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, AuthorizationPeer::ENTITY_ID);
    $c->add(AuthorizationPeer::ENTITY_TYPE_ID, 1);
    $c->add(AuthorizationPeer::PERSON_ID, $personId);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn(self::NICKNAME);
    $c->setDistinct();

    return self::doSelect($c);
  }



  /**
   * Find a list of My Projects with an option OrderBy
   *
   * @param int $personId
   * @param String $orderby
   * @return array <Project>
   */
  public static function findMyProjectsWithOrder($personId, $orderby) {

    $c = new Criteria();
    $c->add(self::PROJID,
            self::PROJID . " IN (
              SELECT DISTINCT P.PROJID
              FROM PROJECT P, AUTHORIZATION A
              WHERE P.DELETED = 0 AND A.ENTITY_TYPE_ID = 1 AND A.ENTITY_ID = P.PROJID AND A.PERSON_ID = $personId
            )", Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn($orderby);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project that are not type of SuperProject that can be viewed by any one
   *
   * @param String $orderby
   * @return array <Project>
   */
  public static function findViewableNotSuperProjectsWithOrder($orderby) {

    $subquery = self::PROJID . " IN (" . self::VIEWABLE_PROJECTS_SUBQUERY . ")";

    $c = new Criteria();
    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT, Criteria::NOT_EQUAL);
    $c->addAscendingOrderByColumn($orderby);
    return self::doSelect($c);
  }


  /**
   * Find a list of Viewable Projects that are type of SuperProject
   *
   * @param String $orderby
   * @return array <Project>
   */
  public static function findViewableSuperProjectsWithOrder($orderby) {

    $subquery = self::PROJID . " IN (" . self::VIEWABLE_PROJECTS_SUBQUERY . ")";

    $c = new Criteria();
    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT);
    $c->addAscendingOrderByColumn($orderby);
    return self::doSelect($c);
  }


  /**
   * Find a list of Project that are not type of SuperProject
   *
   * @param int $personId
   * @param String $orderby
   * @return array <Project>
   */
  public static function findMyNotSuperProjectsWithOrder($personId, $orderby) {

    $c = new Criteria();
    $c->addJoin(self::PROJID, AuthorizationPeer::ENTITY_ID);
    $c->add(AuthorizationPeer::ENTITY_TYPE_ID, 1);
    $c->add(AuthorizationPeer::PERSON_ID, $personId);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT, Criteria::NOT_EQUAL);
    $c->addAscendingOrderByColumn($orderby);
    return self::doSelect($c);
  }


  /**
   * Find a list of Project that are type of SuperProject
   *
   * @param int $personId
   * @param String $orderby
   * @return array <Project>
   */
  public static function findMySuperProjectsWithOrder($personId, $orderby) {

    $c = new Criteria();
    $c->addJoin(self::PROJID, AuthorizationPeer::ENTITY_ID);
    $c->add(AuthorizationPeer::ENTITY_TYPE_ID, 1);
    $c->add(AuthorizationPeer::PERSON_ID, $personId);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT);
    $c->addAscendingOrderByColumn($orderby);
    return self::doSelect($c);
  }


  /**
   * Find all sub-projects belong to a project group
   *
   * @param int $super_projid
   * @return array[Project]
   */
  public static function findSubProjects($super_projid) {

    $c = new Criteria();
    $c->add(self::SUPER_PROJECT_ID, $super_projid);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project that associated with an Organization
   *
   * @param int $orgid
   * @return array <Project>
   */
  public static function findByOrganization($orgid) {

    require_once 'lib/data/ProjectOrganizationPeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, ProjectOrganizationPeer::PROJID);
    $c->add(ProjectOrganizationPeer::ORGID, $orgid);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a Project that matched with an Organization an given by a Project Name
   *
   * @param int $orgid
   * @param String $name
   * @return Project
   */
  public static function findByOrganizationProjectName($orgid, $name) {

    require_once 'lib/data/ProjectOrganizationPeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, ProjectOrganizationPeer::PROJID);
    $c->add(ProjectOrganizationPeer::ORGID, $orgid);
    $c->add(self::NAME, $name);
    $c->add(self::DELETED, 0);

    return self::doSelectOne($c);
  }


  /**
   * Find a list of Project that matched with a title
   *
   * @param String $title
   * @return array <Project>
   */
  public static function findByTitle($title) {

    $c = new Criteria();
    $c->add(self::TITLE, $title);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project that funded by Organization
   *
   * @param String $fundorg
   * @return array <Project>
   */
  public static function findByFundingOrganization($fundorg) {

    $c = new Criteria();
    $c->add(self::FUNDORG, $fundorg);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a Project by project id
   *
   * @param int $projid
   * @return Project
   */
  public static function findByProjectId($projid) {
    return find($projid);
  }


  /**
   * Find a list of Project by its status
   *
   * @param String $status
   * @return array <Project>
   */
  public static function findByStatus($status) {

    $c = new Criteria();
    $c->add(self::STATUS, $status);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project by its curation status
   *
   * @param String $curation_status
   * @return array <Project>
   */
  public static function findByCurationStatus($curation_status) {

    $c = new Criteria();
    $c->add(self::CURATION_STATUS, $curation_status);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project by its viewable column
   *
   * @param String $viewable
   * @return array <Project>
   */
  public static function findByVisibility($viewable) {

    $c = new Criteria();
    $c->add(self::VIEWABLE, $viewable);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }



  /**
   * Find all Public Viewable Projects with an option Order by
   *
   * @param String $orderby
   * @return array <Project>
   */
  public static function findPubProjectsWithOrder($orderby) {

    $c = new Criteria();
    $subquery = self::PROJID . " IN (" . self::PUB_PROJECTS_SUBQUERY . ")";
    $c->add(self::PROJID , $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn($orderby);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }



  /**
   * Find all Public Viewable Projects with an option Order by
   *
   * @param String $orderby
   * @return array <Project>
   */
  public static function findCuratedProjectsWithOrder($orderby) {

    $curatedIds = NCCuratedObjectsPeer::getCuratedProjectsMap();
    $curatedIdsStr = implode(",", $curatedIds);

    $c = new Criteria();
    $subquery = self::PROJID . " IN (" . $curatedIdsStr . ")";
    $c->add(self::PROJID , $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn($orderby);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }


  /**
   * Get the list of ProjID and number of public experiments in these project
   * if Project have at LEAST ONE public Experiment. This will help a lot to reduce
   * number of database calls for each Project in TreeBrowser and ListAllProjects, ListMyProject
   *
   * @return array(projid => num_pub_exps)
   */
  public static function findViewableProjectIdsHasPublishedExperiment() {

    $conn = Propel::getConnection();
    $stmt = $conn->createStatement();
    $sql = "SELECT PROJID, COUNT(*) AS COUNT FROM EXPERIMENT WHERE VIEWABLE = 'PUBLIC' AND DELETED = 0 GROUP BY PROJID ORDER BY PROJID";
    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_ASSOC);
    $projids = array();
    while($rs->next()) {
      $projids[$rs->get('PROJID')] = $rs->get('COUNT');
    }
    return $projids;
  }


  /**
   * Get the list of ProjectGroup ID
   *
   * @return array(projid)
   */
  public static function findProjectGroupIds() {

    $conn = Propel::getConnection();
    $stmt = $conn->createStatement();
    $sql = "SELECT PROJID FROM PROJECT WHERE PROJECT_TYPE_ID = 3 AND DELETED = 0";
    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_ASSOC);
    $projids = array();
    while($rs->next()) {
      $projids[] = $rs->get('PROJID');
    }
    return $projids;
  }


  /**
   * Find all Viewable Projects with an option OrderBy
   *
   * @return array <Project>
   */
  public static function findViewableProjectWithOrder($orderby = self::NICKNAME) {

    $c = new Criteria();

    $subquery = self::PROJID . " IN (" . self::VIEWABLE_PROJECTS_SUBQUERY . ")";

    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn($orderby);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);

  }



  /**
   * Find number of Published Experiments belong to a Project
   *
   * @param int $projid
   * @return int count
   */
  public static function findNumberOfPublishedExperiments($projid) {

    require_once 'lib/data/ExperimentPeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, ExperimentPeer::PROJID, Criteria::INNER_JOIN);
    $c->add(ExperimentPeer::STATUS, 'published');
    $c->add(self::DELETED, 0);
    $c->add(ExperimentPeer::DELETED, 0);
    $c->add(self::PROJID, $projid);

    return self::doCount($c);
  }


  /**
   * Mark a Project with deleted = true given by Project ID
   *
   * @param int $projid
   */
  public static function deleteProjectById($projid) {
    if($proj = self::retrieveByPK($projid)) {
      $proj->setDeleted(true);
      $proj->save();
    }
  }



  /**
   * Set a project name based on id, used right after save a Project
   * to make sure a Project Name matched with Project ID
   *
   * @param Project $proj
   */
  private static function updateProjectName(Project $proj) {
    $id = $proj->getId();
    $name = sprintf("NEES-%04s-%04d",date("Y"),$id);
    $proj->setName($name);
    $proj->save();
  }


  /**
   * Get Number of Public Experiments belong to a Project
   *
   * @param int $projid
   * @return int count
   */
  public static function getNumPublicExperiments($projid) {
    require_once 'lib/data/ExperimentPeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, ExperimentPeer::PROJID, Criteria::INNER_JOIN);
    $c->add(ExperimentPeer::VIEWABLE, 'PUBLIC');
    $c->add(self::DELETED, 0);
    $c->add(ExperimentPeer::DELETED, 0);
    $c->add(self::PROJID, $projid);

    return self::doCount($c);

  }



  /**
   * Checking if the curren user's projects have at at least one project group or not
   *
   * @param int $personId
   * @return boolean
   */
  public function haveSuperProjects($personId = null) {

    if(is_null($personId)) return false;

    $subquery = self::PROJID . " IN (SELECT ENTITY_ID FROM AUTHORIZATION WHERE ENTITY_TYPE_ID = 1 AND PERSON_ID = $personId)";

    $c = new Criteria();
    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT);

    return count(self::doSelect($c)) > 0;
  }


  /**
   * Checking if there is at least one viewable project that have at at least one project group
   *
   * @return boolean
   */
  public function haveSuperProjectsForViewableProjects() {

    $subquery = self::PROJID . " IN (" . self::VIEWABLE_PROJECTS_SUBQUERY . ")";

    $c = new Criteria();
    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT);

    return count(self::doSelect($c)) > 0;
  }



  /**
   * Find a list of My Projects with an option Order By
   *
   * @param int $uid: Person ID
   * @param String $order: Order By
   * @return array <Project>
   */
  public static function getMyProjectsWithOrder($uid,$order) {
    if (is_null(self::$myprojects)) {
      self::$myprojects = self::findMyProjectsWithOrder($uid,$order);
    }
    return self::$myprojects;
  }


  /**
   * Find a list of Public Projects with an option Order By
   *
   * @param String $order: Order By
   * @return array <Project>
   */
  public static function getPubProjectsWithOrder($order) {
    if (is_null(self::$pubprojects)) {
      self::$pubprojects = self::findPubProjectsWithOrder($order);
    }
    return self::$pubprojects;
  }



  /**
   * Find a list of Public Projects with an option Order By
   *
   * @param String $order: Order By
   * @return array <Project>
   */
  public static function getCuratedProjectsWithOrder($order) {
    if (is_null(self::$curatedprojects)) {
      self::$curatedprojects = self::findCuratedProjectsWithOrder($order);
    }
    return self::$curatedprojects;
  }


  /**
   * Find a list of Viewable Projects with an option order by
   *
   * @param $order: Order By
   * @return array <Project>
   */
  public static function getViewableProjectsWithOrder($order) {
    if (is_null(self::$viewableprojects)) {
      self::$viewableprojects = self::findViewableProjectWithOrder($order);
    }
    return self::$viewableprojects;
  }



  /**
   * Find a list of Project IDs that a Person can do
   * @param int $personId
   * @param String $canDo: a Permission that person can do
   *
   * @return array <Project ID>
   */
  public static function listProjectIdsPersonCanDo($personId, $canDo) {

    $conn = Propel::getConnection();
    $stmt = $conn->createStatement();
    $sql  = "
      SELECT PROJID FROM PROJECT WHERE PROJID IN
        (SELECT ENTITY_ID FROM AUTHORIZATION WHERE PERSON_ID = $personId AND ENTITY_TYPE_ID = 1 AND INSTR(PERMISSIONS,'$canDo') >0)";

    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_ASSOC);
    $projids = array();
    while($rs->next()) {
      $projids[] = $rs->get('PROJID');
    }
    return $projids;
  }


  /**
   * Check if Project title is duplicated with other Project's title or not
   *
   * @param String $title: The title to be checked (ignore case)
   * @param int $projid: optional, null by default. If not null, we should ignore the title of that Projid
   * @return boolean value, true if duplicated, else false
   */
  public static function isDuplicatedTitle($title, $projid = null) {
    $title = trim($title);

    $c = new Criteria();
    $c->add(self::TITLE, $title);

    if( ! is_null($projid)) {
      $c->add(self::PROJID, $projid, Criteria::NOT_EQUAL);
    }
    $c->add(self::DELETED, 0);
    $c->setIgnoreCase(true);

    return self::doCount($c) > 0;
  }


  /**
   * Check if Project Nickname is duplicated with other Project's nickname or not
   *
   * @param String $nickname: The nickname to be checked (ignore case)
   * @param int $projid: optional, null by default. If not null, we should ignore the nickname of that Projid
   * @return boolean value, true if duplicated, else false
   */
  public static function isDuplicatedNickname($nickname, $projid = null) {
    $nickname = trim($nickname);

    $c = new Criteria();
    $c->add(self::NICKNAME, $nickname);

    if( ! is_null($projid)) {
      $c->add(self::PROJID, $projid, Criteria::NOT_EQUAL);
    }
    $c->add(self::DELETED, 0);
    $c->setIgnoreCase(true);

    return self::doCount($c) > 0;
  }


  /**
   * Find total number of Active Projects (not deleted project)
   *
   * @return int $count
   */
  public function countActiveProjects() {

    $sql = "SELECT COUNT(*) AS COUNT FROM PROJECT WHERE deleted = 0";

    $conn = Propel::getConnection();
    $stmt = $conn->createStatement();
    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_ASSOC);

    if($rs->next()) {
      return $rs->get('COUNT');
    }
    return -1;
  }


  /**
   * Find a list of Projects from an array of projids
   *
   * @param array $projids
   * array[Project]
   */
  public function findFromListOfIds($projids) {

    if(!is_array($projids)) return array();

    $c = new Criteria();
    $c->add(self::PROJID, $projids, Criteria::IN);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }

} // ProjectPeer
?>
