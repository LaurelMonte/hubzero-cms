<?php

// include base peer class
require_once 'lib/data/om/BaseProjectPeer.php';

// include object class
include_once 'lib/data/Project.php';
include_once 'lib/data/Experiment.php';
include_once 'lib/data/curation/NCCuratedObjects.php';

/**
 * Skeleton subclass for performing query and update operations on the 'Project' table.
 *
 *
 *
 * This class was autogenerated by Propel on:
 *
 * Sat Feb  9 00:03:06 2008
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.data
 */
class ProjectPeer extends BaseProjectPeer {

  static $myprojects = null;
  static $viewableprojects = null;
  static $pubprojects = null;
  static $curatedprojects = null;

  const VIEWABLE_PROJECTS_SUBQUERY =
      "SELECT DISTINCT PROJID FROM PROJECT WHERE DELETED = 0 AND VIEWABLE = 'PUBLIC'
      UNION
      SELECT E1.PROJID FROM PROJECT P1, EXPERIMENT E1 WHERE P1.DELETED = 0 AND P1.PROJID = E1.PROJID AND E1.VIEWABLE = 'PUBLIC'";

  const MY_PROJECTS_SUBQUERY =
      "SELECT DISTINCT P.PROJID
      FROM
          PROJECT P,
          AUTHORIZATION A
      WHERE
          P.DELETED = 0 AND
          A.ENTITY_TYPE_ID = 1 AND
          A.ENTITY_ID = P.PROJID AND
          A.PERSON_ID = ? ";

  const PUB_PROJECTS_SUBQUERY =
      "SELECT DISTINCT PROJID
      FROM
          PROJECT
      WHERE
          DELETED = 0 AND
          PROJID IN (SELECT PROJID FROM EXPERIMENT WHERE VIEWABLE = 'PUBLIC' AND DELETED = 0)";

  public static function getKeywordSearchColumns() {
    return array(self::NAME, self::TITLE, self::DESCRIPTION, self::CONTACT_NAME, self::SYSADMIN_NAME, self::NICKNAME);
  }


  /**
   *
   *
   */
  public static function search($searchTerms) {
    if (!$searchTerms || $searchTerms == "") {
      return null;
    }
    $searchTerms = "%$searchTerms%";
    $searchColumns = self::getKeywordSearchColumns();


    $c = new Criteria();

    $cond = array();
    foreach($searchColumns as $column){
      $cond[] = "$column LIKE '$searchTerms'";
    }
    $condStr = implode($cond, " OR ");

    $c->add(self::NAME, $condStr, Criteria::CUSTOM);
    return self::doSelect($c);
  }
  
  /**
   * 
   *
   */
  public static function searchByForm($p_strQuery){
  	$oConnection = Propel::getConnection();
    $oStatement = $oConnection->createStatement();
    $oResultsSet = $oStatement->executeQuery($p_strQuery, ResultSet::FETCHMODE_ASSOC);

    /*
     * It seems as if populate objects doesn't like row_number().
     * Thus, we're creating the objects via primary key.  
     * 
     * return parent::populateObjects($oResultsSet);
     */
    $iProjectIdArray = array();
    while($oResultsSet->next()){
      $iProjectId = $oResultsSet->getInt('PROJID');
      array_push($iProjectIdArray, $iProjectId);
    }
    return ProjectPeer::retrieveByPKs($iProjectIdArray);
  }
  
  /**
   * 
   *
   */
  public static function searchByFormCount($p_strQuery, $p_strField){
  	$oConnection = Propel::getConnection();
    $oStatement = $oConnection->createStatement();
    $oResultsSet = $oStatement->executeQuery($p_strQuery, ResultSet::FETCHMODE_ASSOC);

    $iTotal = 0;
    while($oResultsSet->next()){
      $iTotal = $oResultsSet->getInt($p_strField);
    }
    return $iTotal;
  }

  /**
   * Get a list of projects using a specified keyword.
   * 
   * TODO: Look for quotes and possibly use the in cluase.  See hub search.
   * @deprecated
   */
  public static function searchByKeywords($p_strSearchTerms, $p_strOrderBy="name", $p_iLowerLimit=1, $p_iUpperLimit=25){
  	if(!$p_strSearchTerms || $p_strSearchTerms == ""){
  	  return null;
  	}
  	
  	$p_strSearchTerms = "%$p_strSearchTerms%";
  	$strSearchColumns = self::getKeywordSearchColumns();
  	
  	//see if any of the searchable columns contain a search term
    $strConditionArray = array();
    foreach($strSearchColumns as $strColumn){
      $strConditionArray[] = "lower(" . $strColumn . ") LIKE '" . strtolower($p_strSearchTerms) . "'";
    }
    
    //turn the array into a single string
    $strCondition = implode($strConditionArray, " OR ");
    $strCondition = "(" . $strCondition . ")";
    
  	$strQuery = "SELECT * 
				 FROM (
				   SELECT PROJECT.*, row_number() 
				   OVER (ORDER BY $p_strOrderBy desc) as rn 
				   FROM PROJECT 
				   WHERE deleted = 0 
				     AND $strCondition 
				 )  
				 WHERE rn BETWEEN $p_iLowerLimit AND $p_iUpperLimit";
  	
//  echo $strQuery."<br>";
  	
  	$oConnection = Propel::getConnection();
    $oStatement = $oConnection->createStatement();
    $oResultsSet = $oStatement->executeQuery($strQuery, ResultSet::FETCHMODE_ASSOC);

    /*
     * It seems as if populate objects doesn't like row_number().
     * Thus, we're creating the objects via primary key.  I'm sure 
     * that this is causing some overhead!
     * 
     * return parent::populateObjects($oResultsSet);
     */
    $iProjectIdArray = array();
    while($oResultsSet->next()){
      $iProjectId = $oResultsSet->getInt('PROJID');
      array_push($iProjectIdArray, $iProjectId);
    }
    return ProjectPeer::retrieveByPKs($iProjectIdArray);
  }
  
  public static function searchByKeywordsCount($p_strSearchTerms){
    if(!$p_strSearchTerms || $p_strSearchTerms == ""){
  	  return null;
  	}
  	
  	$p_strSearchTerms = "%$p_strSearchTerms%";
  	$strSearchColumns = self::getKeywordSearchColumns();
  	
  	//see if any of the searchable columns contain a search term
    $strConditionArray = array();
    foreach($strSearchColumns as $strColumn){
      $strConditionArray[] = "lower(" . $strColumn . ") LIKE '" . strtolower($p_strSearchTerms) . "'";
    }
    
    //turn the array into a single string
    $strCondition = implode($strConditionArray, " OR ");
    $strCondition = "(" . $strCondition . ")";
    
  	$strQuery = "SELECT COUNT(PROJECT.PROJID) AS TOTAL
				 FROM PROJECT 
				 WHERE deleted = 0 
				   AND $strCondition";
  	
  	$iReturnCount = 0;
  	$oConnection = Propel::getConnection();
    $oStatement = $oConnection->createStatement();
    $oResultsSet = $oStatement->executeQuery($strQuery, ResultSet::FETCHMODE_ASSOC);
    if($oResultsSet->next()){
      $iReturnCount = $oResultsSet->getInt('TOTAL');
    }
    //echo "ProjectPeer:count=".$iReturnCount."<br>";
    return $iReturnCount;
  }
  
  /**
   * Find Project by ProjectID or Project Name
   *
   * @param String/int $idOrName
   * @return Project
   */
  public static function find($idOrName) {
    return self::findByNameOrId($idOrName, $idOrName);
  }


  /**
   * Find all none-deleted Project
   *
   * @return array <Project>
   */
  public static function findAll() {
    $c = new Criteria();
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn(self::TITLE);

    return self::doSelect($c);
  }


  /**
   * Find One Matched Projected given by either Project Name or Project ID
   *
   * @param String $name
   * @param int $projid
   * @return Project
   */
  public static function findByNameOrId($name, $projid) {

    $c = new Criteria();

    $cton1 = $c->getNewCriterion(self::NAME, $name);
    $cton2 = $c->getNewCriterion(self::PROJID, $projid);
    $cton1->addOr($cton2);
    $c->add($cton1);
    $c->add(self::DELETED, 0);

    return self::doSelectOne($c);
  }



  /**
   * Find One Matched Projected given by a Project Name
   *
   * @param String $name
   * @return Project
   */
  public static function findByName($name) {

    $c = new Criteria();

    $c->add(self::NAME, $name);
    $c->add(self::DELETED, 0);

    return self::doSelectOne($c);
  }



  /**
   * Find a list of Project that a Person has a permission
   *
   * @param int $personId
   * @return array <Project>
   */
  public static function findByPerson($personId) {

    require_once 'lib/data/PersonEntityRolePeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, AuthorizationPeer::ENTITY_ID);
    $c->add(AuthorizationPeer::ENTITY_TYPE_ID, 1);
    $c->add(AuthorizationPeer::PERSON_ID, $personId);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn(self::NICKNAME);
    $c->setDistinct();

    return self::doSelect($c);
  }



  /**
   * Find a list of My Projects with an option OrderBy
   *
   * @param int $personId
   * @param String $orderby
   * @return array <Project>
   */
  public static function findMyProjectsWithOrder($personId, $orderby) {

    $c = new Criteria();
    $c->add(self::PROJID,
            self::PROJID . " IN (
              SELECT DISTINCT P.PROJID
              FROM PROJECT P, AUTHORIZATION A
              WHERE P.DELETED = 0 AND A.ENTITY_TYPE_ID = 1 AND A.ENTITY_ID = P.PROJID AND A.PERSON_ID = $personId
            )", Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn($orderby);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project that are not type of SuperProject that can be viewed by any one
   *
   * @param String $orderby
   * @return array <Project>
   */
  public static function findViewableNotSuperProjectsWithOrder($orderby) {

    $subquery = self::PROJID . " IN (" . self::VIEWABLE_PROJECTS_SUBQUERY . ")";

    $c = new Criteria();
    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT, Criteria::NOT_EQUAL);
    $c->addAscendingOrderByColumn($orderby);
    return self::doSelect($c);
  }


  /**
   * Find a list of Viewable Projects that are type of SuperProject
   *
   * @param String $orderby
   * @return array <Project>
   */
  public static function findViewableSuperProjectsWithOrder($orderby) {

    $subquery = self::PROJID . " IN (" . self::VIEWABLE_PROJECTS_SUBQUERY . ")";

    $c = new Criteria();
    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT);
    $c->addAscendingOrderByColumn($orderby);
    return self::doSelect($c);
  }


  /**
   * Find a list of Project that are not type of SuperProject
   *
   * @param int $personId
   * @param String $orderby
   * @return array <Project>
   */
  public static function findMyNotSuperProjectsWithOrder($personId, $orderby) {

    $c = new Criteria();
    $c->addJoin(self::PROJID, AuthorizationPeer::ENTITY_ID);
    $c->add(AuthorizationPeer::ENTITY_TYPE_ID, 1);
    $c->add(AuthorizationPeer::PERSON_ID, $personId);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT, Criteria::NOT_EQUAL);
    $c->addAscendingOrderByColumn($orderby);
    return self::doSelect($c);
  }


  /**
   * Find a list of Project that are type of SuperProject
   *
   * @param int $personId
   * @param String $orderby
   * @return array <Project>
   */
  public static function findMySuperProjectsWithOrder($personId, $orderby) {

    $c = new Criteria();
    $c->addJoin(self::PROJID, AuthorizationPeer::ENTITY_ID);
    $c->add(AuthorizationPeer::ENTITY_TYPE_ID, 1);
    $c->add(AuthorizationPeer::PERSON_ID, $personId);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT);
    $c->addAscendingOrderByColumn($orderby);
    return self::doSelect($c);
  }


  /**
   * Find all sub-projects belong to a project group
   *
   * @param int $super_projid
   * @return array[Project]
   */
  public static function findSubProjects($super_projid) {

    $c = new Criteria();
    $c->add(self::SUPER_PROJECT_ID, $super_projid);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project that associated with an Organization
   *
   * @param int $orgid
   * @return array <Project>
   */
  public static function findByOrganization($orgid) {

    require_once 'lib/data/ProjectOrganizationPeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, ProjectOrganizationPeer::PROJID);
    $c->add(ProjectOrganizationPeer::ORGID, $orgid);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a Project that matched with an Organization an given by a Project Name
   *
   * @param int $orgid
   * @param String $name
   * @return Project
   */
  public static function findByOrganizationProjectName($orgid, $name) {

    require_once 'lib/data/ProjectOrganizationPeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, ProjectOrganizationPeer::PROJID);
    $c->add(ProjectOrganizationPeer::ORGID, $orgid);
    $c->add(self::NAME, $name);
    $c->add(self::DELETED, 0);

    return self::doSelectOne($c);
  }


  /**
   * Find a list of Project that matched with a title
   *
   * @param String $title
   * @return array <Project>
   */
  public static function findByTitle($title) {

    $c = new Criteria();
    $c->add(self::TITLE, $title);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project that funded by Organization
   *
   * @param String $fundorg
   * @return array <Project>
   */
  public static function findByFundingOrganization($fundorg) {

    $c = new Criteria();
    $c->add(self::FUNDORG, $fundorg);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a Project by project id
   *
   * @param int $projid
   * @return Project
   */
  public static function findByProjectId($projid) {
    return find($projid);
  }


  /**
   * Find a list of Project by its status
   *
   * @param String $status
   * @return array <Project>
   */
  public static function findByStatus($status) {

    $c = new Criteria();
    $c->add(self::STATUS, $status);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project by its curation status
   *
   * @param String $curation_status
   * @return array <Project>
   */
  public static function findByCurationStatus($curation_status) {

    $c = new Criteria();
    $c->add(self::CURATION_STATUS, $curation_status);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }


  /**
   * Find a list of Project by its viewable column
   *
   * @param String $viewable
   * @return array <Project>
   */
  public static function findByVisibility($viewable) {

    $c = new Criteria();
    $c->add(self::VIEWABLE, $viewable);
    $c->add(self::DELETED, 0);

    return self::doSelect($c);
  }



  /**
   * Find all Public Viewable Projects with an option Order by
   *
   * @param String $orderby
   * @return array <Project>
   */
  public static function findPubProjectsWithOrder($orderby) {

    $c = new Criteria();
    $subquery = self::PROJID . " IN (" . self::PUB_PROJECTS_SUBQUERY . ")";
    $c->add(self::PROJID , $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn($orderby);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }



  /**
   * Find all Public Viewable Projects with an option Order by
   *
   * @param String $orderby
   * @return array <Project>
   */
  public static function findCuratedProjectsWithOrder($orderby) {

    $curatedIds = NCCuratedObjectsPeer::getCuratedProjectsMap();
    $curatedIdsStr = implode(",", $curatedIds);

    $c = new Criteria();
    $subquery = self::PROJID . " IN (" . $curatedIdsStr . ")";
    $c->add(self::PROJID , $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn($orderby);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }


  /**
   * Get the list of ProjID and number of public experiments in these project
   * if Project have at LEAST ONE public Experiment. This will help a lot to reduce
   * number of database calls for each Project in TreeBrowser and ListAllProjects, ListMyProject
   *
   * @return array(projid => num_pub_exps)
   */
  public static function findViewableProjectIdsHasPublishedExperiment() {

    $conn = Propel::getConnection();
    $stmt = $conn->createStatement();
    $sql = "SELECT PROJID, COUNT(*) AS COUNT FROM EXPERIMENT WHERE VIEWABLE = 'PUBLIC' AND DELETED = 0 GROUP BY PROJID ORDER BY PROJID";
    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_ASSOC);
    $projids = array();
    while($rs->next()) {
      $projids[$rs->get('PROJID')] = $rs->get('COUNT');
    }
    return $projids;
  }


  /**
   * Get the list of ProjectGroup ID
   *
   * @return array(projid)
   */
  public static function findProjectGroupIds() {

    $conn = Propel::getConnection();
    $stmt = $conn->createStatement();
    $sql = "SELECT PROJID FROM PROJECT WHERE PROJECT_TYPE_ID = 3 AND DELETED = 0";
    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_ASSOC);
    $projids = array();
    while($rs->next()) {
      $projids[] = $rs->get('PROJID');
    }
    return $projids;
  }


  /**
   * Find all Viewable Projects with an option OrderBy
   *
   * @return array <Project>
   */
  public static function findViewableProjectWithOrder($orderby = self::NICKNAME) {

    $c = new Criteria();

    $subquery = self::PROJID . " IN (" . self::VIEWABLE_PROJECTS_SUBQUERY . ")";

    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->addAscendingOrderByColumn($orderby);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);

  }



  /**
   * Find number of Published Experiments belong to a Project
   *
   * @param int $projid
   * @return int count
   */
  public static function findNumberOfPublishedExperiments($projid) {

    require_once 'lib/data/ExperimentPeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, ExperimentPeer::PROJID, Criteria::INNER_JOIN);
    $c->add(ExperimentPeer::STATUS, 'published');
    $c->add(self::DELETED, 0);
    $c->add(ExperimentPeer::DELETED, 0);
    $c->add(self::PROJID, $projid);

    return self::doCount($c);
  }


  /**
   * Mark a Project with deleted = true given by Project ID
   *
   * @param int $projid
   */
  public static function deleteProjectById($projid) {
    if($proj = self::retrieveByPK($projid)) {
      $proj->setDeleted(true);
      $proj->save();
    }
  }



  /**
   * Set a project name based on id, used right after save a Project
   * to make sure a Project Name matched with Project ID
   *
   * @param Project $proj
   */
  private static function updateProjectName(Project $proj) {
    $id = $proj->getId();
    $name = sprintf("NEES-%04s-%04d",date("Y"),$id);
    $proj->setName($name);
    $proj->save();
  }


  /**
   * Get Number of Public Experiments belong to a Project
   *
   * @param int $projid
   * @return int count
   */
  public static function getNumPublicExperiments($projid) {
    require_once 'lib/data/ExperimentPeer.php';

    $c = new Criteria();
    $c->addJoin(self::PROJID, ExperimentPeer::PROJID, Criteria::INNER_JOIN);
    $c->add(ExperimentPeer::VIEWABLE, 'PUBLIC');
    $c->add(self::DELETED, 0);
    $c->add(ExperimentPeer::DELETED, 0);
    $c->add(self::PROJID, $projid);

    return self::doCount($c);

  }



  /**
   * Checking if the curren user's projects have at at least one project group or not
   *
   * @param int $personId
   * @return boolean
   */
  public function haveSuperProjects($personId = null) {

    if(is_null($personId)) return false;

    $subquery = self::PROJID . " IN (SELECT ENTITY_ID FROM AUTHORIZATION WHERE ENTITY_TYPE_ID = 1 AND PERSON_ID = $personId)";

    $c = new Criteria();
    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT);

    return count(self::doSelect($c)) > 0;
  }


  /**
   * Checking if there is at least one viewable project that have at at least one project group
   *
   * @return boolean
   */
  public function haveSuperProjectsForViewableProjects() {

    $subquery = self::PROJID . " IN (" . self::VIEWABLE_PROJECTS_SUBQUERY . ")";

    $c = new Criteria();
    $c->add(self::PROJID, $subquery, Criteria::CUSTOM);
    $c->add(self::DELETED, 0);
    $c->add(self::PROJECT_TYPE_ID, self::CLASSKEY_SUPERPROJECT);

    return count(self::doSelect($c)) > 0;
  }



  /**
   * Find a list of My Projects with an option Order By
   *
   * @param int $uid: Person ID
   * @param String $order: Order By
   * @return array <Project>
   */
  public static function getMyProjectsWithOrder($uid,$order) {
    if (is_null(self::$myprojects)) {
      self::$myprojects = self::findMyProjectsWithOrder($uid,$order);
    }
    return self::$myprojects;
  }


  /**
   * Find a list of Public Projects with an option Order By
   *
   * @param String $order: Order By
   * @return array <Project>
   */
  public static function getPubProjectsWithOrder($order) {
    if (is_null(self::$pubprojects)) {
      self::$pubprojects = self::findPubProjectsWithOrder($order);
    }
    return self::$pubprojects;
  }



  /**
   * Find a list of Public Projects with an option Order By
   *
   * @param String $order: Order By
   * @return array <Project>
   */
  public static function getCuratedProjectsWithOrder($order) {
    if (is_null(self::$curatedprojects)) {
      self::$curatedprojects = self::findCuratedProjectsWithOrder($order);
    }
    return self::$curatedprojects;
  }


  /**
   * Find a list of Viewable Projects with an option order by
   *
   * @param $order: Order By
   * @return array <Project>
   */
  public static function getViewableProjectsWithOrder($order) {
    if (is_null(self::$viewableprojects)) {
      self::$viewableprojects = self::findViewableProjectWithOrder($order);
    }
    return self::$viewableprojects;
  }



  /**
   * Find a list of Project IDs that a Person can do
   * @param int $personId
   * @param String $canDo: a Permission that person can do
   *
   * @return array <Project ID>
   */
  public static function listProjectIdsPersonCanDo($personId, $canDo) {

    $conn = Propel::getConnection();
    $stmt = $conn->createStatement();
    $sql  = "
      SELECT PROJID FROM PROJECT WHERE PROJID IN
        (SELECT ENTITY_ID FROM AUTHORIZATION WHERE PERSON_ID = $personId AND ENTITY_TYPE_ID = 1 AND INSTR(PERMISSIONS,'$canDo') >0)";

    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_ASSOC);
    $projids = array();
    while($rs->next()) {
      $projids[] = $rs->get('PROJID');
    }
    return $projids;
  }


  /**
   * Check if Project title is duplicated with other Project's title or not
   *
   * @param String $title: The title to be checked (ignore case)
   * @param int $projid: optional, null by default. If not null, we should ignore the title of that Projid
   * @return boolean value, true if duplicated, else false
   */
  public static function isDuplicatedTitle($title, $projid = null) {
    $title = trim($title);

    $c = new Criteria();
    $c->add(self::TITLE, $title);

    if( ! is_null($projid)) {
      $c->add(self::PROJID, $projid, Criteria::NOT_EQUAL);
    }
    $c->add(self::DELETED, 0);
    $c->setIgnoreCase(true);

    return self::doCount($c) > 0;
  }


  /**
   * Check if Project Nickname is duplicated with other Project's nickname or not
   *
   * @param String $nickname: The nickname to be checked (ignore case)
   * @param int $projid: optional, null by default. If not null, we should ignore the nickname of that Projid
   * @return boolean value, true if duplicated, else false
   */
  public static function isDuplicatedNickname($nickname, $projid = null) {
    $nickname = trim($nickname);

    $c = new Criteria();
    $c->add(self::NICKNAME, $nickname);

    if( ! is_null($projid)) {
      $c->add(self::PROJID, $projid, Criteria::NOT_EQUAL);
    }
    $c->add(self::DELETED, 0);
    $c->setIgnoreCase(true);

    return self::doCount($c) > 0;
  }


  /**
   * Find total number of Active Projects (not deleted project)
   *
   * @return int $count
   */
  public function countActiveProjects() {

    $sql = "SELECT COUNT(*) AS COUNT FROM PROJECT WHERE deleted = 0";

    $conn = Propel::getConnection();
    $stmt = $conn->createStatement();
    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_ASSOC);

    if($rs->next()) {
      return $rs->get('COUNT');
    }
    return -1;
  }


  /**
   * Find a list of Projects from an array of projids
   *
   * @param array $projids
   * array[Project]
   */
  public function findFromListOfIds($projids) {

    if(!is_array($projids)) return array();

    $c = new Criteria();
    $c->add(self::PROJID, $projids, Criteria::IN);
    $c->addAscendingOrderByColumn(self::PROJID);

    return self::doSelect($c);
  }
  
  public static function getFundingOrgs(){
  	$strFundingOrgsArray = array();
	
  	$strQuery = "select distinct (p.fundorg) AS FUND_TYPE
				from project p
				where lower(p.fundorg) not like '%test%'
				  and lower(p.fundorg) != 'none'
				  and lower(p.fundorg) not like 'none.%'
				  and lower(p.fundorg) != 'n/a'
				  and lower(p.fundorg) != 'non applicable'
				  and lower(p.fundorg) != 'not applicable'
				  and lower(p.fundorg) not like '%no funding organization%'
				  and lower(p.fundorg) not like '%no funding oranization%'
				  and lower(p.fundorg) not like '%mom and data%'
				  and lower(p.fundorg) not like '%my pool of funding%'
				  and lower(p.fundorg) != 'me'
				  and lower(p.fundorg) != 'unfunded'
				order by p.fundorg";
  	
    $oConnection = Propel::getConnection();
    $oStatement = $oConnection->createStatement();
    $oResultsSet = $oStatement->executeQuery($strQuery, ResultSet::FETCHMODE_ASSOC);

    $strFundingArray = array();
    while($oResultsSet->next()){
      $strFundType = $oResultsSet->getString('FUND_TYPE');
      array_push($strFundingArray, $strFundType);
    }
    
  	return $strFundingArray;
  }
  
  public static function getTop10Searches(){
  	$oReturnArray = array();
  	
  	$strQuery = "select * 
				from (
				  select count(keyword) as cnt, keyword, row_number()
				  over (order by count(keyword) desc, keyword) as rn
				  from search_log
				  group by keyword
				) where rn <= 10";
  	
    $oConnection = Propel::getConnection();
    $oStatement = $oConnection->createStatement();
    $oResultsSet = $oStatement->executeQuery($strQuery, ResultSet::FETCHMODE_ASSOC);   
    while($oResultsSet->next()){
      $iCount = $oResultsSet->getInt('CNT');
      $strKeyword = $oResultsSet->getString('KEYWORD');
      
      $oSearchArray = array();
      $oSearchArray['COUNT'] = $iCount;
      $oSearchArray['KEYWORD'] = $strKeyword;
      
      array_push($oReturnArray, $oSearchArray);
    }
    
    return $oReturnArray;
  }
  
  public static function findTools($p_iProjectId){
  	$oReturnArray = array();
  	
  	$strQuery = "select distinct df.opening_tool 
				from data_file_link dfl, 
					 data_file df 
			    where dfl.id = df.id
			      and dfl.proj_id = $p_iProjectId
			      and df.opening_tool is not null";
  	
    $oConnection = Propel::getConnection();
    $oStatement = $oConnection->createStatement();
    //$oStatement->setInt(1, $p_iProjectId);
    $oResultsSet = $oStatement->executeQuery($strQuery, ResultSet::FETCHMODE_ASSOC);   
    while($oResultsSet->next()){
      $strTool = $oResultsSet->getString('OPENING_TOOL');
      array_push($oReturnArray, $strTool);
    }
    
    return $oReturnArray;
  }
  
} // ProjectPeer
?>
